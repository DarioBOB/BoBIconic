Voici un retour d√©taill√© sur votre fichier **`WindowPage`**, en v√©rifiant point par point que la logique correspond bien √† ce que vous souhaitez (simulation du vol, calcul de position/altitude, affichage des POIs, int√©gration des deux hublots, etc.). Je commente les sections importantes, signale les petites inexactitudes ou am√©liorations possibles, et m‚Äôassure que tout cadre avec le composant `WindowHublotComponent` que vous avez montr√© pr√©c√©demment.

---

## 1. Imports et d√©finitions globales

```ts
import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { IonicModule } from '@ionic/angular';
import { DateTime, Duration } from 'luxon';
import { Firestore, collection, query, where, getDocs } from '@angular/fire/firestore';
import { Auth, onAuthStateChanged, User } from '@angular/fire/auth';
import { IonPopover } from '@ionic/angular';
import * as L from 'leaflet';
import { WindowMapTestComponent } from './window-map-test.component';
import { FlightDataService } from '../services/flight/flight-data.service';
import { FlightData } from '../services/flight/models/flight.interface';
import { WindowHublotComponent } from '../components/window-hublot.component';
```

* **`DateTime`, `Duration` (Luxon)**
  Vous utilisez Luxon pour g√©rer les horodatages, ce qui est tout √† fait correct.

* **`Firestore` / `Auth` / `IonPopover` / `Leaflet`**
  Certains imports (Firestore, Auth, IonPopover, Leaflet) ne sont pour l‚Äôinstant pas exploit√©s dans votre code (`getDocs`, `onAuthStateChanged`, `IonPopover` et `L` n‚Äôapparaissent pas dans la logique de la page).

  * Si vous pr√©voyez d‚Äôajouter √† terme du Firebase ou un popover Ionic, gardez-les, sinon vous pouvez supprimer ces imports pour all√©ger la build.
  * Le composant `WindowMapTestComponent` est cens√© afficher la carte ‚Äúcockpit‚Äù/itin√©raire, vous l‚Äôimportez bien.

* **`WindowHublotComponent`**
  Le composant standalone pour les hublots est bien import√© : vous pourrez l‚Äôutiliser dans la `template` de cette page.

---

## 2. D√©finition de l‚Äôinterface et constantes de POIs (ALL\_POIS + profil d‚Äôaltitude)

Vous avez d√©fini :

```ts
interface POI {
  name: string;
  description: string;
  wiki_url: string;
  lat: number;
  lon: number;
  side: 'left' | 'right';
  type: 'nature' | 'montagne' | 'ville' | 'historique' | 'eau' | 'parc' | 'plage' | 'vallee' | 'archipel' | 'port' | 'quartier' | 'colline' | 'autre';
}

// Exemple de base de POIs (√† compl√©ter)
const ALL_POIS: POI[] = [ ‚Ä¶ ];
```

* **‚úîÔ∏è Coh√©rence**

  * Chaque POI contient bien `name`, `description`, `wiki_url`, `lat`, `lon`, `side`, `type`.
  * Les `side: 'left' | 'right'` servent ensuite √† filtrer les POIs visibles √† gauche ou √† droite du vol.

* **Petite am√©lio**

  * Vous n‚Äôavez pas de champ `image_url` dans l‚Äôinterface `POI`, pourtant dans la popup vous testez `*ngIf="selectedPOI.image_url"`.

    * **Constat** : qui veut dire que, pour l‚Äôinstant, `selectedPOI.image_url` sera toujours `undefined` ‚Üí l‚Äôimage ne s‚Äôaffichera jamais √† l‚Äôint√©rieur de la popover.
    * **Solution rapide** : soit vous l‚Äôajoutez dans l‚Äôinterface (et fournissez un lien vers une image pour chaque POI), soit vous enlevez ce test dans le template (ou le remplacez par un champ `iconUrl` si vous souhaitez un pictogramme).

---

## 3. Fonctions de calcul (haversine, interpolation, POIs, altitude)

Vous avez cod√© :

```ts
// 1) Fonction haversine (approx. grand-cercle)
function haversine(a: {lat: number, lon: number}, b: {lat: number, lon: number}): number {
  const R = 6371;
  const dLat = (b.lat - a.lat) * Math.PI / 180;
  const dLon = (b.lon - a.lon) * Math.PI / 180;
  const lat1 = a.lat * Math.PI / 180;
  const lat2 = b.lat * Math.PI / 180;
  const x = dLon * Math.cos((lat1 + lat2) / 2);
  return Math.sqrt(dLat * dLat + x * x) * R;
}

// 2) getClosestPOIs : filte ALL_POIS selon side, trie par distance, renvoie les N plus proches
function getClosestPOIs(position: {lat: number, lon: number}, side: 'left' | 'right', count: number): POI[] {
  const candidates = ALL_POIS.filter(poi => poi.side === side);
  candidates.sort((a, b) => haversine(position, a) - haversine(position, b));
  return candidates.slice(0, count);
}

// 3) Interpolation lin√©aire entre deux points
function interpolatePosition(
  start: {lat: number, lon: number},
  end:   {lat: number, lon: number},
  fraction: number
): {lat: number, lon: number} {
  return {
    lat: start.lat + (end.lat - start.lat) * fraction,
    lon: start.lon + (end.lon - start.lon) * fraction
  };
}

// 4) getRealisticAltitude : interpolation lin√©aire sur REAL_ALTITUDE_PROFILE
function getRealisticAltitude(progressPercent: number): number {
  // progressPercent ‚àà [0, 100], on trouve l'indice de tranche (par pas de 10)
  const idx = Math.floor(progressPercent / 10);
  const nextIdx = Math.min(idx + 1, REAL_ALTITUDE_PROFILE.length - 1);
  const pctInStep = (progressPercent % 10) / 10;
  const alt1 = REAL_ALTITUDE_PROFILE[idx];
  const alt2 = REAL_ALTITUDE_PROFILE[nextIdx];
  return alt1 + (alt2 - alt1) * pctInStep;
}

// 5) generateWaypointsWithPOIs : g√©n√®re nSteps √©tapes depuis start jusqu'√† end
function generateWaypointsWithPOIs(
  start: {lat: number, lon: number},
  end:   {lat: number, lon: number},
  allPOIs: POI[],
  nSteps: number = 10
) {
  const waypoints: any[] = [];
  for (let i = 0; i <= nSteps; i++) {
    const fraction = i / nSteps;                // ex. 0.0, 0.1, 0.2, ‚Ä¶, 1.0
    const pos = interpolatePosition(start, end, fraction);
    const pct = Math.round(fraction * 100);     // ex. 0%, 10%, 20%, ‚Ä¶, 100%
    const altitude = getRealisticAltitude(pct); // en ft (pieds)

    // POIs les plus proches √† gauche et √† droite
    const poisLeft  = getClosestPOIs(pos, 'left',  3);
    const poisRight = getClosestPOIs(pos, 'right', 3);

    waypoints.push({
      pct,
      lat: pos.lat,
      lon: pos.lon,
      altitude,                  // en pieds
      poi_left:  poisLeft.map(poi => ({ ...poi, altitude })),
      poi_right: poisRight.map(poi => ({ ...poi, altitude }))
    });
  }
  return waypoints;
}
```

### V√©rifications

1. **Haversine**

   * Vous utilisez une version simplifi√©e (approximation ¬´ cos moyenne ¬ª) qui n‚Äôest pas l‚Äôalgorithme haversine ¬´ complet ¬ª, mais pour trier des distances sur quelques milliers de kilom√®tres, c‚Äôest suffisant.
   * Elle renvoie une distance en **kilom√®tres** (car R = 6371 km). OK pour trier les POIs.

2. **Filtrage + tri des POIs**

   * `getClosestPOIs(position, side, count)` ‚Üí renvoie bien les `count` plus proches parmi ceux dont `poi.side === side`.
   * C‚Äôest ce qu‚Äôon veut pour afficher les POIs √† gauche / droite, en fonction de la position instantan√©e.

3. **Interpolation lin√©aire de position**

   * Pour un vol ‚Äútrajet‚Äù en ligne droite entre deux a√©roports, vous interpolez les latitudes/longitudes de fa√ßon lin√©aire.
   * Si vous vouliez un ‚Äúgrand cercle‚Äù plus pr√©cis, il faudrait appliquer la formule de ‚Äúslerp‚Äù sur la sph√®re, mais pour un vol court GVA‚ÄìATH, l‚Äô√©cart sera minime. OK.

4. **Profil d‚Äôaltitude (`getRealisticAltitude`)**

   * Vous avez un tableau `REAL_ALTITUDE_PROFILE` qui correspond √† 0% ‚Üí 0 ft, 10% ‚Üí 12 000 ft, 20% ‚Üí 26 000 ft, ‚Ä¶, 100% ‚Üí 0 ft.
   * La TVL de d√©collage/mont√©e ‚Üí croisi√®re ‚Üí descente est bien mod√©lis√©e par interpolation par pas de 10 %.
   * **Attention** : `progressPercent` est un entier de 0 √† 100. S‚Äôil est, par exemple, √† 25 %,

     * `idx = Math.floor(25 / 10) = 2`
     * `nextIdx = 3`
     * `pctInStep = (25 % 10) / 10 = 0.5`
     * altitude = `alt1 + (alt2 ‚Äì alt1) * 0.5 = REAL_ALTITUDE_PROFILE[2] + 0.5 √ó (REAL_ALTITUDE_PROFILE[3] ‚Äì REAL_ALTITUDE_PROFILE[2]) = 26000 + 0.5√ó(35000 ‚Äì 26000) = 26000 + 4500 = 30500 ft`.
   * C‚Äôest coh√©rent.

5. **`generateWaypointsWithPOIs`**

   * Vous produisez un tableau de 11 √©l√©ments (de i = 0 √† 10), chacun contenant :

     * `pct` = 0, 10, 20, ‚Ä¶, 100
     * `lat` et `lon` interpol√©s
     * `altitude` (en ft) √† partir du profil
     * `poi_left` et `poi_right` : chacun est un tableau de 3 POIs, avec en plus la propri√©t√© `altitude` ajout√©e.
   * On note que vous passez bien `lat/lon` **num√©riques** (float), et `altitude` en *ft*.

√Ä ce stade, ces fonctions font exactement ce qu‚Äôon attend :

* on a un jeu de waypoints pr√©d√©finis
* √† chaque 10 % de progression correspond une position, une altitude, et 3 POIs pour chaque c√¥t√©.

---

## 4. L√©gende des ic√¥nes de pin

```ts
function getPinIconForType(type: string): string {
  switch (type) {
    case 'montagne':   return 'assets/pin_montagne.png';
    case 'ville':      return 'assets/pin_ville.png';
    case 'eau':        return 'assets/pin_eau.png';
    case 'historique': return 'assets/pin_historique.png';
    case 'nature':     return 'assets/pin_nature.png';
    case 'parc':       return 'assets/pin_parc.png';
    case 'plage':      return 'assets/pin_plage.png';
    case 'vallee':     return 'assets/pin_vallee.png';
    case 'archipel':   return 'assets/pin_archipel.png';
    case 'port':       return 'assets/pin_port.png';
    case 'quartier':   return 'assets/pin_quartier.png';
    case 'colline':    return 'assets/pin_colline.png';
    default:           return 'assets/pin.png';
  }
}
```

* **‚úîÔ∏è** Chaque type renvoie bien vers un fichier dans `assets/`.
* **‚úì** Si `type` ne correspond √† aucun des cas, on utilise `assets/pin.png` par d√©faut.

---

## 5. Le composant Angular : `WindowPage`

### 5.1 D√©corateur `@Component`

```ts
@Component({
  selector: 'app-window',
  standalone: true,
  template: `
    <ion-content>
      <!-- Carte principale (cockpit/itin√©raire) -->
      <app-window-map-test
        [lat]="flightData?.lat_t_deg"
        [lon]="flightData?.lon_t_deg"
        [altitude]="flightData?.altitude || 11000"
        [poisVisibles]="getVisiblePOIs()">
      </app-window-map-test>

      <!-- Si on a des donn√©es de vol (flightData), on affiche les infos ... -->
      <div class="placeholder-container" *ngIf="flightData">
        <h1>‚úàÔ∏è Vol d√©mo Gen√®ve ‚Üí Ath√®nes <ion-badge color="warning">DEMO</ion-badge></h1>
        <div class="flight-info-block">
          <div><b>D√©part :</b> {{ flightData.departureCity }} ({{ flightData.departureAirport }})</div>
          <div><b>Heure de d√©part :</b> {{ flightData.departureTimeGeneva }} (GVA) / {{ flightData.departureTimeAthens }} (ATH)</div>
          <div><b>Arriv√©e :</b> {{ flightData.arrivalCity }} ({{ flightData.arrivalAirport }})</div>
          <div><b>Heure d'arriv√©e :</b> {{ flightData.arrivalTimeAthens }} (ATH) / {{ flightData.arrivalTimeGeneva }} (GVA)</div>
          <div><b>Num√©ro de vol :</b> {{ flightData.flightNumber }} | <b>Compagnie :</b> {{ flightData.airline }}</div>
          <div><b>Avion :</b> {{ flightData.aircraft }}</div>
        </div>

        <div class="progress-block">
          <h2>üïí Statut du vol</h2>
          <div><b>Heure actuelle √† Gen√®ve :</b> {{ flightData.nowGeneva }} (GVA) / {{ flightData.nowAthens }} (ATH)</div>
          <div><b>Heure actuelle √† Ath√®nes :</b> {{ flightData.nowAthens }} (ATH) / {{ flightData.nowGeneva }} (GVA)</div>
          <div><b>Progression du vol :</b> {{ flightData.progressPercent }} %</div>
          <div><b>Temps √©coul√© en vol :</b> {{ flightData.elapsed }}</div>
          <div><b>Temps restant :</b> {{ flightData.remaining }}</div>
          <div><b>Dur√©e totale du vol :</b> {{ flightData.duration }}</div>
          <div><b>Statut :</b> {{ flightData.status }}</div>
          <div><b>Phase de vol :</b> {{ flightData.phase }}</div>
          <div><b>Vitesse sol :</b> {{ flightData.v_sol_kt }} kt ({{ flightData.v_sol_kmh }} km/h)</div>
          <div><b>Distance parcourue :</b> {{ flightData.d_elapsed_km }} km</div>
          <div><b>Distance restante :</b> {{ flightData.d_remaining_km }} km</div>
          <div><b>Fraction du trajet :</b> {{ flightData.fraction_f }} %</div>
          <div><b>Coordonn√©es actuelles :</b> {{ flightData.lat_t_deg }} N, {{ flightData.lon_t_deg }} E</div>
          <div><b>Altitude avion :</b> {{ flightData.altitude | number:'1.0-0' }} ft ({{ (flightData.altitude * 0.3048) | number:'1.0-0' }} m)</div>

          <div class="poi-section"><b>Points d'int√©r√™t √† gauche :</b>
            <ul>
              <li *ngFor="let poi of currentPOI.left">
                <a href="#" (click)="openPOIPopover(poi, $event); $event.preventDefault()">
                  <b>{{ poi.name }}</b>
                </a>
                <div class="poi-desc">{{ poi.description }}</div>
              </li>
            </ul>
          </div>

          <div class="poi-section"><b>Points d'int√©r√™t √† droite :</b>
            <ul>
              <li *ngFor="let poi of currentPOI.right">
                <a href="#" (click)="openPOIPopover(poi, $event); $event.preventDefault()">
                  <b>{{ poi.name }}</b>
                </a>
                <div class="poi-desc">{{ poi.description }}</div>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <!-- Si flightData est null -->
      <div *ngIf="!flightData">
        <ion-icon name="map-outline" class="placeholder-icon"></ion-icon>
        <h1>Ma Fen√™tre</h1>
        <p>Aucun vol d√©mo en cours.</p>
      </div>

      <!-- Popup POI (overlay) -->
      <div *ngIf="showPOIModal && selectedPOI" class="poi-popup-overlay" (click)="closePOIPopover()">
        <div class="poi-popup-waw" (click)="$event.stopPropagation()">
          <div class="poi-popup-header">
            <strong>{{ selectedPOI.name }}</strong>
            <button class="poi-popup-close" (click)="closePOIPopover()">‚úï</button>
          </div>
          <div class="poi-popup-body">
            <img *ngIf="selectedPOI.image_url" [src]="selectedPOI.image_url" [alt]="selectedPOI.name" />
            <p class="poi-popup-desc">{{ selectedPOI.description }}</p>
            <p class="poi-popup-coords">
              üìç <em>Lat</em> {{ currentWaypoint?.lat | number:'1.4-4' }} N, 
                   <em>Lon</em> {{ currentWaypoint?.lon | number:'1.4-4' }} E
            </p>
          </div>
          <div class="poi-popup-footer">
            <a *ngIf="selectedPOI.wiki_url" href="{{ selectedPOI.wiki_url }}" target="_blank">Voir sur Wikip√©dia ‚Üó</a>
          </div>
        </div>
      </div>

      <!-- Bloc de test en bas (donn√©es flightTestData) -->
      <ion-card *ngIf="flightTestData">
        <!-- ... nombreux ion-item pour afficher flightTestData ... -->
      </ion-card>

      <!-- Section POIs d√©taill√©e par tranche de 10% -->
      <ion-card *ngIf="waypoints && waypoints.length">
        <ion-card-header>
          <ion-card-title>Points d'int√©r√™t du vol (GVA ‚Üí ATH)</ion-card-title>
          <ion-card-subtitle>Affichage de tous les POIs par tranche de 10%</ion-card-subtitle>
        </ion-card-header>
        <ion-card-content>
          <ion-list>
            <ion-item *ngFor="let wp of waypoints">
              <ion-label>
                <h3>
                  Tranche {{ wp.pct }}% 
                  (Lat: {{ wp.lat | number:'1.4-4' }}, 
                   Lon: {{ wp.lon | number:'1.4-4' }}, 
                   Alt: {{ wp.altitude | number:'1.0-0' }} ft 
                   ({{ (wp.altitude * 0.3048) | number:'1.0-0' }} m), 
                   Zoom: {{ getMapZoomFromAltitude(wp.altitude) }})
                </h3>
                <div>
                  <b>POIs √† gauche :</b>
                  <ul>
                    <li *ngFor="let poi of wp.poi_left">
                      <span 
                        [ngStyle]="isPOIVisible(poi, 'left') 
                                     ? {'color':'#1976d2','font-weight':'bold'} 
                                     : {}">
                        <img [src]="getPinIconForType(poi.type)" 
                             class="poi-type-icon" width="20" height="20" 
                             style="vertical-align:middle;margin-right:6px;" />
                        {{ poi.name }}
                        <span *ngIf="isPOIVisible(poi, 'left')" class="poi-badge">Visible</span>
                      </span>
                      <br><small>{{ poi.description }}</small>
                      <br><a [href]="poi.wiki_url" target="_blank">Wikipedia</a>
                      <br>Coord: {{ poi.lat | number:'1.4-4' }}, {{ poi.lon | number:'1.4-4' }} | 
                          Alt avion: {{ poi.altitude | number:'1.0-0' }} ft 
                          ({{ (poi.altitude * 0.3048) | number:'1.0-0' }} m) | 
                          Zoom: {{ getMapZoomFromAltitude(poi.altitude) }}
                    </li>
                  </ul>
                </div>
                <div>
                  <b>POIs √† droite :</b>
                  <ul>
                    <li *ngFor="let poi of wp.poi_right">
                      <span 
                        [ngStyle]="isPOIVisible(poi, 'right') 
                                     ? {'color':'#1976d2','font-weight':'bold'} 
                                     : {}">
                        <img [src]="getPinIconForType(poi.type)" 
                             class="poi-type-icon" width="20" height="20" 
                             style="vertical-align:middle;margin-right:6px;" />
                        {{ poi.name }}
                        <span *ngIf="isPOIVisible(poi, 'right')" class="poi-badge">Visible</span>
                      </span>
                      <br><small>{{ poi.description }}</small>
                      <br><a [href]="poi.wiki_url" target="_blank">Wikipedia</a>
                      <br>Coord: {{ poi.lat | number:'1.4-4' }}, {{ poi.lon | number:'1.4-4' }} | 
                          Alt avion: {{ poi.altitude | number:'1.0-0' }} ft 
                          ({{ (poi.altitude * 0.3048) | number:'1.0-0' }} m) | 
                          Zoom: {{ getMapZoomFromAltitude(poi.altitude) }}
                    </li>
                  </ul>
                </div>
              </ion-label>
            </ion-item>
          </ion-list>
        </ion-card-content>
      </ion-card>

      <!-- Ligne de hublots en bas -->
      <div class="hublots-bottom-row">
        <app-window-hublot 
          [lat]="getHublotLat('left')" 
          [lon]="getHublotLon('left')" 
          [altitude]="flightData?.altitude || 11000" 
          side="left">
        </app-window-hublot>

        <app-window-hublot 
          [lat]="getHublotLat('right')" 
          [lon]="getHublotLon('right')" 
          [altitude]="flightData?.altitude || 11000" 
          side="right">
        </app-window-hublot>
      </div>
    </ion-content>
  `,
  styles: [ /* ... longue liste de styles ... */ ],
  imports: [ CommonModule, IonicModule, WindowMapTestComponent, WindowHublotComponent /*, ‚Ä¶*/ ]
})
```

* **Cas o√π `flightData == null`**
  Vous affichez un message ‚ÄúAucun vol d√©mo en cours.‚Äù gr√¢ce √† `*ngIf="!flightData"`. OK.

* **Bloc ‚ÄúCarte principale‚Äù**

  ```html
  <app-window-map-test 
    [lat]="flightData?.lat_t_deg" 
    [lon]="flightData?.lon_t_deg" 
    [altitude]="flightData?.altitude || 11000" 
    [poisVisibles]="getVisiblePOIs()">
  </app-window-map-test>
  ```

  * Vous passez `lat` et `lon` √† `WindowMapTestComponent` sous forme de `flightData.lat_t_deg` et `flightData.lon_t_deg`.
  * **Point √† v√©rifier** : dans `updateDemoFlight()`, vous d√©finissez `lat_t_deg` et `lon_t_deg` en faisant `toFixed(4)`, ce qui renvoie une **cha√Æne** (string).

    * Mais `WindowMapTestComponent` s‚Äôattend tr√®s probablement √† recevoir un **nombre** pour `lat` et `lon` (typiquement un `@Input() lat: number;`).
    * **Recommandation** : soit changez vos assignations pour donner `lat_t_deg: parseFloat(someNumber.toFixed(4))`, soit dans le binding faites `[lat]="parseFloat(flightData.lat_t_deg)"`.
    * Sinon, Angular essaiera de ‚Äúconvertir‚Äù la cha√Æne en nombre au runtime, mais c‚Äôest mieux de garder un nombre pur.
  * L‚Äô`altitude` que vous passez est en **pieds** (ex. 11000 ft). Si `WindowMapTestComponent`/Leaflet attend une altitude en ft pour faire son calcul de zoom, c‚Äôest coh√©rent. Sinon, v√©rifiez bien l‚Äôunit√©.

* **Affichage des donn√©es de vol**
  Le template (`flight-info-block` et `progress-block`) semble tout √† fait correct et coh√©rent avec ce que vous calculez dans `updateDemoFlight()` (vitesse, distance, heures, etc.).

* **Section POIs ‚Äú√† gauche‚Äù et ‚Äú√† droite‚Äù**
  Vous affichez une liste de liens cliquables (POI.name). Au clic, vous appelez `openPOIPopover(poi, $event)` et emp√™chez (`$event.preventDefault()`) la navigation. OK.

  * Vous mettez la description, et plus bas le pop-up d√©taill√© ‚Äúpoi-popup-overlay‚Äù qui s‚Äôouvre si `showPOIModal` est √† `true`.

* **Bloc ‚ÄúDonn√©es enrichies du vol test‚Äù**
  Facultatif, c‚Äôest votre ‚Äúconsole‚Äù pour afficher les donn√©es en provenance de l‚ÄôAPI Aviationstack & OpenSky. √áa a l‚Äôair d√©coupl√© de la logique principale (pas de lien avec `WindowMapTestComponent`). Ce bloc fonctionne uniquement si `flightTestData` n‚Äôest pas `null`.

* **Liste d√©taill√©e ‚ÄúPOIs du vol (GVA ‚Üí ATH)‚Äù**
  Ici, vous parcourez `waypoints` (tableau g√©n√©r√© dans `ngOnInit`) pour afficher, pour chaque tranche 0%,10%,‚Ä¶100% :

  * latitude, longitude, altitude, zoom calcul√© par `getMapZoomFromAltitude()`,
  * puis liste de POIs √† gauche et √† droite, et sur chaque POI vous coloriez en bleu / gras s‚Äôil est ‚Äúvisible‚Äù (`isPOIVisible`).
  * Cette section est purement ‚Äúd√©bogage / inventaire‚Äù pour voir comment √©voluent vos POIs sur les 10 tranches. Cela marche correctement, √† condition que `waypoints` ait bien √©t√© initialis√©.

* **Les deux hublots en bas (classe `hublots-bottom-row`)**

  ```html
  <div class="hublots-bottom-row">
    <app-window-hublot 
      [lat]="getHublotLat('left')" 
      [lon]="getHublotLon('left')" 
      [altitude]="flightData?.altitude || 11000" 
      side="left">
    </app-window-hublot>
    <app-window-hublot 
      [lat]="getHublotLat('right')" 
      [lon]="getHublotLon('right')" 
      [altitude]="flightData?.altitude || 11000" 
      side="right">
    </app-window-hublot>
  </div>
  ```

  * Vous transmettez √† chaque `WindowHublotComponent` un `lat` et `lon` calcul√© via `getHublotLat('left')` / `getHublotLon('left')`, et respectivement `getHublotLat('right')` / `getHublotLon('right')`.
  * Vous transmettez aussi `[altitude]="flightData?.altitude || 11000"` ‚Üí en pieds. C‚Äôest coh√©rent avec le composant hublot, puisqu‚Äôil s‚Äôattend √† recevoir `altitude` en ft et qu‚Äôil convertit ensuite en m quand il fait son calcul interne.
  * **V√©rification de coh√©rence** :

    * `WindowHublotComponent` calcule son zoom via `getZoomFromAltitude(altitudeInFeet, lat)`, mais dans sa version finale (que je vous avais propos√©e), on convertissait explicitement `altitude` en m√®tres avant de faire `zoom = log2(...)`.
    * Ici, comme vous envoyez `altitude` en pieds, dans `WindowHublotComponent` il faut s‚Äôassurer que :

      1. soit `getZoomFromAltitude()` convertit `altitude` de ft ‚Üí m en interne,
      2. soit, dans `WindowPage`, vous remplacez `[altitude]` par `[altitude]="(flightData?.altitude || 11000) * 0.3048"` (c‚Äôest-√†-dire envoyer d√©j√† la valeur en m√®tres).
    * D‚Äôapr√®s le composant `WindowHublotComponent` que vous aviez montr√© avant, il convertissait bien `altitude*0.3048` pour certains calculs, mais il utilisait aussi parfois `altitude` brut dans `getZoomFromAltitude` et `getViewRadius`. Il faut donc rev√©rifier qu‚Äô√† l‚Äôint√©rieur de `WindowHublotComponent` vous avez syst√©matiquement la conversion ft‚Üím avant d‚Äôappeler **toutes** les fonctions qui attendent un h en m√®tre.

---

### 5.2 Styles (abr√©g√©)

Vous avez une longue liste de styles CSS :

* **`.placeholder-container`**, **`.flight-info-block`**, **`.progress-block`**, **`.poi-section`**, etc.
* Le `@keyframes popin`, les styles pour `.poi-popup-overlay`, `.poi-popup-waw`, etc.
* **`.hublots-bottom-row`** : mise en page flex, responsive pour espacer les deux hublots.

Tout cela para√Æt coh√©rent :

* Vous mettez `overflow: hidden` sur `ion-content`, `height: 80vh` sur les cartes, etc.
* Les hublots se retrouvent align√©s en bas, avec un **gap** adapt√© (`gap: 240px` sur grand √©cran, qui se r√©duit sur √©crans plus petits).
* Rien d‚Äôanormal dans ces styles.

---

## 6. Logique du composant TypeScript (`WindowPage`)

Voici la partie la plus critique : la logique de d√©marrage du vol, le calcul des positions et l‚Äôactualisation p√©riodique.

### 6.1 Attributs du composant

```ts
export class WindowPage {
  flightData: any = null;
  intervalId: any;
  loading = true;
  user: User | null = null;
  departure: any = null;
  arrival: any = null;
  waypoints: any[] = [];
  currentPOI: { left: any[]; right: any[] } = { left: [], right: [] };
  public selectedPOI: any = null;
  public showPOIModal: boolean = false;
  public popoverEvent: MouseEvent | null = null;
  public currentWaypoint: any = null;
  flightTestData: FlightData | null = null;

  constructor(
    private firestore: Firestore,
    private auth: Auth,
    private flightDataService: FlightDataService
  ) {}
  // ‚Ä¶
}
```

* `flightData: any = null;`
  Contiendra l‚Äôobjet calcul√© par `updateDemoFlight()`, avec tous les champs d√©crits (d√©part, arriv√©e, progression, etc.).
* `waypoints: any[] = [];`
  Stockera la liste g√©n√©r√©e par `generateWaypointsWithPOIs(...)`.
* `currentPOI`
  Stocke un objet `{ left: POI[], right: POI[] }` pour la tranche courante du vol.
* `selectedPOI`, `showPOIModal`, `popoverEvent`, `currentWaypoint`
  Concernent la gestion de la popup de d√©tail d‚Äôun POI.
* `flightTestData`
  Pour afficher les donn√©es du vol en provenance de l‚ÄôAPI de test (ou de OpenSky), non reli√© √† la m√©canique principale.

### 6.2 `ngOnInit()` : initialisation du vol de d√©mo

```ts
ngOnInit() {
  this.initDemoFlight();

  // G√©n√®re les waypoints √† partir de ALL_POIS
  const start = { lat: 46.2381, lon: 6.1080 }; // Gen√®ve
  const end   = { lat: 37.9364, lon: 23.9445 }; // Ath√®nes
  this.waypoints = generateWaypointsWithPOIs(start, end, ALL_POIS, 10);

  if (this.intervalId) clearInterval(this.intervalId);
  this.intervalId = setInterval(() => {
    this.updateDemoFlight();
    this.updateFlightTestData();
    this.updateCurrentPOI();
  }, 1000);
}
```

* **`this.initDemoFlight()`**
  Va calculer les dates de d√©part/arriv√©e (√† partir de Luxon) et positionner `this.departure` et `this.arrival`.
  Ensuite, `updateDemoFlight()` (appel√© par la suite) va cr√©er `this.flightData` pour la tranche initiale.

* **`this.waypoints = generateWaypointsWithPOIs(start, end, ALL_POIS, 10);`**

  * G√©n√®re 11 points (0%, 10%, ‚Ä¶, 100%)
  * √Ä chaque point, on a `wp.lat`, `wp.lon`, `wp.altitude` (ft), `wp.poi_left` et `wp.poi_right` (chacun un tableau de 3 POIs ayant d√©j√† le champ `.altitude` ajout√©).
  * **OK** : ces waypoints seront utilis√©s ensuite dans l‚Äôaffichage d√©taill√© des POIs, et pour calculer la position/heading courant.

* **`setInterval(...)`**

  * Toutes les secondes, vous appelez :

    1. `this.updateDemoFlight()`   ‚Üí recalcul du `this.flightData` (position, fraction, altitude, etc.)
    2. `this.updateFlightTestData()` ‚Üí mise √† jour de `this.flightTestData`, pour la carte de test (peu li√©e)
    3. `this.updateCurrentPOI()`   ‚Üí calcule les POIs visibles ‚ÄúcurrentPOI‚Äù en fonction de `flightData.progressPercent`

  * **Attention** :

    * Dans `updateDemoFlight()`, vous appelez d√©j√† `this.updateCurrentPOI()` √† la fin.
    * Puis, juste apr√®s, le `setInterval` appelle √† nouveau `updateCurrentPOI()`.
    * Cons√©quence : √† chaque tick, `updateCurrentPOI()` est invoqu√© deux fois de suite. Ce n‚Äôest pas dramatique (√ßa reste une simple op√©ration en m√©moire), mais vous pourriez supprimer l‚Äôun des deux appels pour n‚Äôavoir qu‚Äôune seule invocation par seconde.

---

### 6.3 `ngOnDestroy()` : nettoyage

```ts
ngOnDestroy() {
  if (this.intervalId) clearInterval(this.intervalId);
}
```

* **‚úîÔ∏è** Votre `setInterval` sera bien annul√© quand la page sera d√©truite, ce qui √©vite de continuer √† mettre √† jour en arri√®re-plan.

---

### 6.4 `initDemoFlight()` et `updateDemoFlight()`

#### 6.4.1 `initDemoFlight()`

```ts
initDemoFlight() {
  // Param√®tres du vol
  const durationMin = 165; // 2h45

  const now = DateTime.now();
  // Pour simuler qu'on est √† 25% du vol au d√©marrage
  const percent = 0.25;
  const elapsedMs = Math.round(durationMin * 60 * 1000 * percent);

  this.departure = now.minus({ milliseconds: elapsedMs });
  this.arrival   = this.departure.plus({ minutes: durationMin });

  this.updateDemoFlight();
}
```

* **Objectif** :

  * Pour faire d√©marrer la d√©mo ‚Äúau milieu du vol‚Äù, on d√©termine `departure` comme ‚Äúil y a x minutes‚Äù (x = 0.25 √ó 165).
  * `this.arrival` = `this.departure + 165 minutes`.
  * Puis on lance imm√©diatement `updateDemoFlight()` pour peupler `this.flightData`.

* **‚úîÔ∏è** Rien √† redire ici. C‚Äôest uniquement pour initialiser les dates du vol de d√©mo.

#### 6.4.2 `updateDemoFlight()`

C‚Äôest la fonction principale qui construit `this.flightData`.

```ts
updateDemoFlight() {
  if (!this.departure || !this.arrival) return;

  const now = DateTime.now();

  // 1) D√©finition des a√©roports GVA & ATH
  const gva = {
    code: 'GVA', city: 'Gen√®ve', name: 'A√©roport de Gen√®ve',
    tz: 'Europe/Zurich', lat: 46.2381, lon: 6.1080
  };
  const ath = {
    code: 'ATH', city: 'Ath√®nes', name: "A√©roport d'Ath√®nes...",
    tz: 'Europe/Athens', lat: 37.9364, lon: 23.9445
  };

  // 2) Profil de vol
  const t_total_min   = 148;    // dur√©e totale en minutes
  const t_climb      = 20;     // mont√©e en minutes
  const t_descent    = 30;     // descente en minutes
  const KT_TO_KMH    = 1.852;
  const v_climb_kt   = 280;
  const v_descent_kt = 300;
  const v_climb_kmh   = v_climb_kt * KT_TO_KMH;
  const v_descent_kmh = v_descent_kt * KT_TO_KMH;

  const t_cruise      = t_total_min - t_climb - t_descent; // 148 - 20 - 30 = 98 min
  const t_cruise_h    = t_cruise / 60;                     // environ 1,63 h

  // 3) Calcul haversine pour la distance grand cercle (en km)
  const R = 6371;
  const toRad = (deg: number) => deg * Math.PI / 180;
  const œÜ1 = toRad(gva.lat), œÜ2 = toRad(ath.lat);
  const Œª1 = toRad(gva.lon), Œª2 = toRad(ath.lon);
  const ŒîœÜ = toRad(ath.lat - gva.lat);
  const ŒîŒª = toRad(ath.lon - gva.lon);
  const hav = (Œî: number) => Math.sin(Œî / 2) ** 2;
  const a = hav(ŒîœÜ) + Math.cos(œÜ1) * Math.cos(œÜ2) * hav(ŒîŒª);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const D_gc_km = R * c; // distance grand cercle en km

  // 4) Calibration des phases mont√©e / croisi√®re / descente :
  const d_climb   = v_climb_kmh   * (t_climb   / 60);  // km parcourus en mont√©e
  const d_descent = v_descent_kmh * (t_descent / 60);  // km parcourus en descente
  const v_cruise_kmh = (D_gc_km - d_climb - d_descent) / t_cruise_h;
  const v_cruise_kt  = v_cruise_kmh / KT_TO_KMH;
  const d_cruise      = v_cruise_kmh * t_cruise_h;

  // 5) Temps √©coul√© depuis le d√©part
  const total   = this.arrival.diff(this.departure);   // Duration Luxon totale
  const elapsed = now.diff(this.departure);             // Duration Luxon √©coul√©e
  const t_elapsed_min = elapsed.as('minutes');

  let phase = '';
  let v_sol_kt = 0, v_sol_kmh = 0, d_elapsed_km = 0;

  if (t_elapsed_min <= t_climb) {
    phase = 'Mont√©e';
    v_sol_kt  = v_climb_kt;
    v_sol_kmh = v_climb_kmh;
    d_elapsed_km = v_climb_kmh * (t_elapsed_min / 60);
  } else if (t_elapsed_min <= t_climb + t_cruise) {
    phase = 'Croisi√®re';
    v_sol_kt  = v_cruise_kt;
    v_sol_kmh = v_cruise_kmh;
    const dt_cruise     = t_elapsed_min - t_climb;
    d_elapsed_km = d_climb + v_cruise_kmh * (dt_cruise / 60);
  } else {
    phase = 'Descente';
    v_sol_kt  = v_descent_kt;
    v_sol_kmh = v_descent_kmh;
    const dt_desc     = t_elapsed_min - t_climb - t_cruise;
    d_elapsed_km = d_climb + d_cruise + v_descent_kmh * (dt_desc / 60);
  }

  const fraction_f = Math.max(0, Math.min(1, d_elapsed_km / D_gc_km));

  // 6) Interpolation de la position actuelle (grand-cercle) :
  const Œ¥ = c;
  const A = Math.sin((1 - fraction_f) * Œ¥) / Math.sin(Œ¥);
  const B = Math.sin(fraction_f * Œ¥) / Math.sin(Œ¥);
  const x = A * Math.cos(œÜ1) * Math.cos(Œª1) + B * Math.cos(œÜ2) * Math.cos(Œª2);
  const y = A * Math.cos(œÜ1) * Math.sin(Œª1) + B * Math.cos(œÜ2) * Math.sin(Œª2);
  const z = A * Math.sin(œÜ1) + B * Math.sin(œÜ2);
  const œÜ_t = Math.atan2(z, Math.sqrt(x * x + y * y));
  const Œª_t = Math.atan2(y, x);
  const lat_t_deg = toDeg(œÜ_t);
  const lon_t_deg = toDeg(Œª_t);

  // 7) Horaires format√©s
  const depTimeGeneva  = this.departure.setZone(gva.tz);
  const depTimeAthens  = this.departure.setZone(ath.tz);
  const arrTimeGeneva  = this.arrival  .setZone(gva.tz);
  const arrTimeAthens  = this.arrival  .setZone(ath.tz);
  const nowGeneva      = now.setZone(gva.tz);
  const nowAthens      = now.setZone(ath.tz);

  // 8) Statut du vol
  const progress = Math.max(0, Math.min(1, elapsed.as('milliseconds') / total.as('milliseconds')));
  let statusDesc = '';
  if (progress < 0)   statusDesc = 'En attente';
  else if (progress >= 1) statusDesc = 'Arriv√©';
  else                  statusDesc = 'En vol';
  const status = { type: 'ON_TIME', description: statusDesc };

  // 9) Altitude (ft) selon le profil r√©el
  const progressPercent = Math.round(progress * 100);
  const altitude = getRealisticAltitude(progressPercent);

  // 10) Assemblage de l‚Äôobjet flightData
  const newFlightData = {
    departureCity: gva.city,
    departureAirport: gva.code,
    departureTimeGeneva: depTimeGeneva.toFormat('HH:mm dd LLL yyyy'),
    departureTimeAthens: depTimeAthens.toFormat('HH:mm dd LLL yyyy'),
    departureTZGeneva: gva.tz,
    departureTZAthens: ath.tz,
    arrivalCity: ath.city,
    arrivalAirport: ath.code,
    arrivalTimeGeneva: arrTimeGeneva.toFormat('HH:mm dd LLL yyyy'),
    arrivalTimeAthens: arrTimeAthens.toFormat('HH:mm dd LLL yyyy'),
    arrivalTZGeneva: gva.tz,
    arrivalTZAthens: ath.tz,
    flightNumber: 'EZS1528',
    airline: 'easyJet',
    aircraft: 'Airbus A320',
    nowGeneva: nowGeneva.toFormat('HH:mm:ss dd LLL yyyy'),
    nowAthens: nowAthens.toFormat('HH:mm:ss dd LLL yyyy'),
    progressPercent: Math.round(progress * 100),
    elapsed: progress < 0 ? '0 min' : Duration.fromMillis(Math.max(0, elapsed.as('milliseconds'))).toFormat('h:mm'),
    remaining: progress >= 1 ? '0 min' : Duration.fromMillis(Math.max(0, total.as('milliseconds') - elapsed.as('milliseconds'))).toFormat('h:mm'),
    duration: Duration.fromMillis(total.as('milliseconds')).toFormat('h:mm'),
    status,
    phase,
    v_sol_kt: Math.round(v_sol_kt),
    v_sol_kmh: Math.round(v_sol_kmh),
    d_elapsed_km: Math.round(d_elapsed_km),
    d_remaining_km: Math.round(D_gc_km - d_elapsed_km),
    D_gc_km: Math.round(D_gc_km),
    fraction_f: Math.round(fraction_f * 100),
    lat_t_deg: lat_t_deg.toFixed(4),
    lon_t_deg: lon_t_deg.toFixed(4),
    altitude  // en ft
  };

  console.log('[WindowPage] updateDemoFlight progressPercent:', newFlightData.progressPercent, '√†', new Date().toISOString());
  this.flightData = { ...newFlightData, altitude };

  // Mise √† jour des POIs visibles
  this.updateCurrentPOI();
  this.loading = false;
}
```

#### Points cl√©s et v√©rifications

1. **Calcul de la distance grand-cercle**

   * Vous employez la formule exacte de l‚Äôarc de grand-cercle (avec `haversine` plus complet).
   * `D_gc_km` : distance en km entre GVA et ATH. Parfait.

2. **Phase Mont√©e / Croisi√®re / Descente**

   * Vous d√©finissez :

     * mont√©e : 20 min √† 280 kt (‚âà 280 √ó 1.852 = \~518 km/h)
     * descente : 30 min √† 300 kt (\~556 km/h)
     * croisi√®re : reste (\~98 min) √† `v_cruise_kmh` que vous calculez en soustrayant les distances de mont√©e et de descente.
   * Le calcul est coh√©rent et permet de conna√Ætre la progression exacte en km, vous en d√©duisez `fraction_f` pour interpoler la position.
   * ‚úÖ **C‚Äôest conforme**.

3. **Interpolation de position (grand-cercle)**

   * Vous utilisez la m√©thode dite ‚Äúformule de Rhumb line‚Äù (slerp) avec A et B comme coefficients.
   * R√©sultat : `(lat_t_deg, lon_t_deg)` est la position interm√©diaire √† la fraction donn√©e.
   * ‚úÖ **OK**.

4. **La donn√©e `lat_t_deg` et `lon_t_deg` sont TOUS DEUX des cha√Ænes** (`string`) √† cause de `.toFixed(4)`.

   * Au moment d‚Äôinstaller `this.flightData = { ‚Ä¶ lat_t_deg: '46.2381', lon_t_deg: '6.1080', ‚Ä¶ }`, **ces deux champs sont des cha√Ænes**.
   * Comme on l‚Äôa dit, si on les bondit vers un composant qui attend des `@Input() lat: number`, ce peut √™tre probl√©matique.
   * **Correction** : Il faudrait faire soit :

     ```ts
     const latNum = parseFloat(lat_t_deg.toFixed(4));
     const lonNum = parseFloat(lon_t_deg.toFixed(4));
     // ‚Ä¶ puis stocker lat_t_deg: latNum, lon_t_deg: lonNum
     ```

     ou bien

     ```ts
     lat_t_deg: Number(lat_t_deg.toFixed(4)),
     lon_t_deg: Number(lon_t_deg.toFixed(4)),
     ```

     pour s‚Äôassurer que le type reste bien `number`.

5. **Calcul de l‚Äôaltitude**

   * Vous l‚Äôobtenez via `getRealisticAltitude(progressPercent)`, qui renvoie un nombre en **pieds**.
   * Vous stockez `altitude` dans `newFlightData`, donc `this.flightData.altitude` est bien un nombre en feet.
   * Plus bas, vous affichez dans le template `{{ flightData.altitude | number:'1.0-0' }} ft ({{ (flightData.altitude * 0.3048) | number:'1.0-0' }} m)` :

     * OK, vous donnez la conversion en m√®tres √† la vol√©e pour l‚Äôutilisateur.
     * Rappel : si vous utilisez ces `altitude` en ft pour vos fonctions Leaflet (WindowHublot), il faut que le composant hublot convertisse correctement ft‚Üím.

6. **Mise √† jour de `this.flightData`**

   * Vous faites `this.flightData = { ...newFlightData, altitude };`.
   * Remarquez que `newFlightData` contient d√©j√† un champ `altitude`. Faire `{ ...newFlightData, altitude }` √©crase √©ventuellement l‚Äôancien `altitude` (m√™me valeur), donc c‚Äôest redondant mais pas erron√©.
   * L‚Äôid√©al aurait √©t√© simplement `this.flightData = newFlightData;`.

7. **`this.updateCurrentPOI()`**

   * Vous appelez cette fonction √† la fin de `updateDemoFlight()`.
   * √áa alimente `this.currentPOI` (POIs gauche/droite) en fonctions de la tranche proche (`progressPercent`) dans `waypoints`.

8. **`this.loading = false`**

   * Indique que la premi√®re boucle d‚Äôupdate est termin√©e. OK.

---

### 6.5 `updateFlightTestData()`

```ts
updateFlightTestData() {
  if (!this.departure || !this.arrival) return;
  const now = DateTime.now();
  // D√©finition de GVA & ATH (m√™me que dans updateDemoFlight)
  const gva = { ‚Ä¶ };
  const ath = { ‚Ä¶ };
  const total = this.arrival.diff(this.departure);
  const elapsed = now.diff(this.departure);
  const progress = Math.max(0, Math.min(1, elapsed.as('milliseconds') / total.as('milliseconds')));
  let statusDesc2 = '';
  if (progress < 0) statusDesc2 = 'En attente';
  else if (progress >= 1) statusDesc2 = 'Arriv√©';
  else statusDesc2 = 'En vol';
  const status2 = { type: 'ON_TIME' as 'ON_TIME', description: statusDesc2 };

  this.flightTestData = {
    flightNumber: 'EZS1528',
    airline: 'easyJet',
    aircraft: { registration: 'HB-JZY', type: 'Airbus A320', icao24: '4b180c' },
    route: {
      departure: { airport: gva.name, city: gva.city, country: 'Suisse', scheduledTime: this.departure.toISO(), actualTime: this.departure.toISO(), terminal: 'T1', gate: 'A12', status: status2, location: { latitude: gva.lat, longitude: gva.lon } },
      arrival:   { airport: ath.name, city: ath.city, country: 'Gr√®ce', scheduledTime: this.arrival.toISO(),  actualTime: this.arrival.toISO(),   terminal: 'M',  gate: 'B7', status: status2, location: { latitude: ath.lat, longitude: ath.lon } },
      currentPosition: { latitude: parseFloat(this.flightData.lat_t_deg), longitude: parseFloat(this.flightData.lon_t_deg), altitude: 11000, speed: 800, heading: 110, timestamp: now.toISO() },
      distance: { kilometers: this.flightData.D_gc_km, miles: Math.round(this.flightData.D_gc_km * 0.621371) },
      duration: { scheduledMinutes: 148 },
      waypoints: []
    },
    status: status2,
    lastUpdated: now.toISO(),
    codeshares: ['U21456', 'LX1234'],
    waypoints: []
  };
}
```

* **But de cette fonction** :

  * Mettre √† jour `this.flightTestData` pour alimenter le bloc ‚ÄúDonn√©es enrichies du vol test‚Äù.
  * Vous fixez `currentPosition.altitude` √† 11000 (ft), `speed: 800`, `heading: 110`.
  * **Erratum potentiel** : vous passez `latitude: parseFloat(this.flightData.lat_t_deg)` et `longitude: parseFloat(this.flightData.lon_t_deg)` (c‚Äôest bien un nombre). OK.

* **Observation** :

  * Vous ne mettez pas de ‚Äúwaypoints‚Äù dans `flightTestData`. Ce champ demeurera un tableau vide (`[]`). Si vous vouliez afficher la liste des waypoints test dans la carte du cockpit, il faudra l‚Äôalimenter dans `waypoints` au lieu de le laisser vide.
  * Si √ßa vous suffit de montrer uniquement ‚ÄúcurrentPosition‚Äù et la route d√©part/arriv√©e, c‚Äôest coh√©rent.

---

### 6.6 `updateCurrentPOI()`

```ts
updateCurrentPOI() {
  // Trouve la tranche de progression la plus proche
  if (!this.flightData || !this.waypoints.length) return;

  const pct = this.flightData.progressPercent;
  let closest = this.waypoints[0];
  let minDiff = 100;
  for (const wp of this.waypoints) {
    const diff = Math.abs(wp.pct - pct);
    if (diff < minDiff) {
      minDiff = diff;
      closest = wp;
    }
  }
  this.currentPOI = { left: closest.poi_left, right: closest.poi_right };
  this.currentWaypoint = closest;
}
```

* **Principe** :

  * On cherche dans `this.waypoints` l‚Äôobjet dont `wp.pct` est le plus proche de `flightData.progressPercent` (0 ‚â§ `pct` ‚â§ 100).
  * On stocke `closest.poi_left` dans `this.currentPOI.left` et `closest.poi_right` dans `this.currentPOI.right`.
  * On conserve aussi `this.currentWaypoint = closest` pour, par exemple, r√©cup√©rer ses coordonn√©es (pop-up POI affiche `currentWaypoint.lat`/`lon`).
* **‚úîÔ∏è C‚Äôest correct**.

---

### 6.7 M√©thodes de gestion de l‚Äôauthentification (`logout()`) et du popover

```ts
async logout() {
  // TODO: Adapter AuthService logout
  // await this.authService.logout();
  window.location.href = '/auth/email';
}

public openPOIPopover(poi: any, event: MouseEvent) {
  this.selectedPOI = poi;
  this.popoverEvent = event;
  this.showPOIModal = true;
}

public closePOIPopover() {
  this.showPOIModal = false;
  this.selectedPOI = null;
  this.popoverEvent = null;
}
```

* **`logout()`** n‚Äôest pas encore impl√©ment√© (TODO).
* **`openPOIPopover()`** / **`closePOIPopover()`** contr√¥lent bien l‚Äôaffichage de la modale POI, en jouant sur `showPOIModal` et `selectedPOI`.
* Le template de la popup ‚Äú`poi-popup-overlay`‚Äù est coh√©rent avec cette logique.

---

### 6.8 `isPOIVisible()` et `getMapZoomFromAltitude()`

```ts
isPOIVisible(poi: any, side: 'left' | 'right'): boolean {
  if (!this.currentPOI) return false;
  return this.currentPOI[side]?.some((p: any) => p.name === poi.name);
}

/**
 * Dans la liste d√©taill√©e, on souhaite calculer un zoom ‚Äúindicatif‚Äù pour chaque POI
 * √† partir de son altitude (en ft). Cette fonction fait un mapping lin√©aire :
 *   altitude ‚àà [0, 40000] ‚Üí zoom ‚àà [13 ‚Ä¶ 6] (invers√©)
 */
getMapZoomFromAltitude(altitude: number): number {
  const minAlt = 0;
  const maxAlt = 40000;
  const minZoom = 6;
  const maxZoom = 13;
  const alt = Math.max(minAlt, Math.min(maxAlt, altitude));
  const zoom = maxZoom - ((alt - minAlt) / (maxAlt - minAlt)) * (maxZoom - minZoom);
  return Math.round(zoom);
}
```

* **`isPOIVisible(poi, side)`**

  * V√©rifie simplement si, dans `this.currentPOI[side]`, il existe un POI dont `name` correspond.
  * OK, c‚Äôest ainsi que vous marquez en gras / bleu les POIs ‚Äúvisibles‚Äù dans la liste d√©taill√©e.

* **`getMapZoomFromAltitude(altitude: number)`**

  * Vous faites un interpol lin√©aire entre altitude=0‚Üízoom=13 et altitude=40000‚Üízoom=6.
  * Dans la section d√©taill√©e ‚ÄúPOIs du vol‚Äù vous affichez `‚Ä¶ Zoom: {{ getMapZoomFromAltitude(poi.altitude) }}`,
  * ‚Üí C‚Äôest une autre √©chelle de zoom, diff√©rente de celle que vous utilisez dans `WindowHublotComponent`.
  * **Attention de bien distinguer** :

    1. Dans la liste des waypoints, vous n‚Äôutilisez ce zoom que pour ‚Äúafficher un chiffre‚Äù √† titre indicatif.
    2. Dans le hublot r√©el (`WindowHublotComponent`), vous calculez votre zoom √† partir d‚Äôune formule plus complexe (`log2(...)`).
  * C‚Äôest une diff√©rence volontaires ou un simple outil de debug ? Si vous voulez aligner les deux formules, il faudra uniformiser.

---

### 6.9 `getVisiblePOIs()`

```ts
getVisiblePOIs(): any[] {
  if (!this.currentPOI) return [];
  return [
    ...(this.currentPOI.left || []),
    ...(this.currentPOI.right || [])
  ].filter(poi =>
    typeof poi.lat === 'number' &&
    typeof poi.lon === 'number' &&
    !isNaN(poi.lat) &&
    !isNaN(poi.lon)
  );
}
```

* Cette fonction prend tous les POIs ‚Äúactuellement visibles‚Äù √† gauche et √† droite et les combine en un seul tableau.
* Utile pour passer au composant `WindowMapTestComponent` la liste des POIs √† afficher sur la carte ‚Äúcockpit‚Äù (trajectory + ic√¥nes).
* **‚úîÔ∏è** Simple, concis, fonctionne.

---

### 6.10 `getPinIconForType()` (wrapper)

```ts
getPinIconForType(type: string): string {
  return getPinIconForType(type);
}
```

* Vous renvoyez simplement la fonction globale d√©finie plus haut. OK.

---

### 6.11 `getHublotLat(side)` et `getHublotLon(side)`

```ts
getHublotLat(side: 'left' | 'right'): number {
  if (!this.flightData) return 0;
  const lat = parseFloat(this.flightData.lat_t_deg);
  const lon = parseFloat(this.flightData.lon_t_deg);
  const cap = this.getCurrentHeading();
  const offsetKm = 10; // d√©calage lat√©ral en km
  const angle = (cap + (side === 'left' ? -90 : 90)) * Math.PI / 180;
  const dLat = (offsetKm / 6371) * Math.cos(angle) * 180 / Math.PI;
  return lat + dLat;
}

getHublotLon(side: 'left' | 'right'): number {
  if (!this.flightData) return 0;
  const lat = parseFloat(this.flightData.lat_t_deg);
  const lon = parseFloat(this.flightData.lon_t_deg);
  const cap = this.getCurrentHeading();
  const offsetKm = 10;
  const angle = (cap + (side === 'left' ? -90 : 90)) * Math.PI / 180;
  const dLon = (offsetKm / 6371) * Math.sin(angle) * 180 / Math.PI / Math.cos(lat * Math.PI / 180);
  return lon + dLon;
}
```

#### Ce qui se passe ici :

1. **R√©cup√©ration de la position centrale**

   * `lat = parseFloat(this.flightData.lat_t_deg)`
   * `lon = parseFloat(this.flightData.lon_t_deg)`
   * On transforme la cha√Æne en nombre (bien, en corrigeant le petit probl√®me de type mentionn√© plus haut).

2. **R√©cup√©ration du cap actuel**

   * On appelle `getCurrentHeading()`, qui d√©termine la direction du vol en regardant les deux waypoints les plus proches.
   * Si pas de donn√©es, vous renvoyez 90¬∞ par d√©faut (Est).

3. **Angle du hublot**

   * √Ä 10 km sur la droite ‚Üí `cap + 90¬∞`
   * √Ä 10 km sur la gauche ‚Üí `cap ‚Äì 90¬∞`
   * On calcule donc `angle` en radians = `(cap ¬± 90) * œÄ/180`.

4. **Calcul de `dLat` et `dLon`**

   * Vous voulez d√©caler la position de 10 km vers la gauche ou la droite.
   * En ‚Äúpetite approximation‚Äù :

     * `dLat = (offsetKm / R) * cos(angle) * (180/œÄ)`
     * `dLon = (offsetKm / R) * sin(angle) * (180/œÄ) / cos(lat)`
   * Explication :

     * `(offsetKm / R)` ‚Üí distance angulaire en radians,
     * `* (180/œÄ)` ‚Üí conversion en degr√©s de latitude,
     * Multipli√© par `cos(angle)` ou `sin(angle)` ‚Üí projet√© sur axe latitude ou longitude.
     * Pour la longitude, on divise par `cos(lat)` pour tenir compte du fait qu‚Äôun degr√© de longitude au sol (km/¬∞) varie selon la latitude.
   * **‚úîÔ∏è C‚Äôest la formule correcte** pour faire un offset ‚Äúest/ouest‚Äù (ou nord/sud) de 10 km autour d‚Äôun point.

5. Vous retournez simplement `lat + dLat` et `lon + dLon`.

   * Parfait pour passer √† `WindowHublotComponent` une coordonn√©e l√©g√®rement d√©cal√©e : chaque hublot regarde donc un poil sur le c√¥t√© (10 km de d√©calage lat√©ralement), ce qui est logique : on ne regarde pas tout droit devant l‚Äôavion, mais un peu sur le c√¥t√© du fuselage.

---

### 6.12 `getCurrentHeading()`

```ts
getCurrentHeading(): number {
  if (this.flightData && this.waypoints && this.waypoints.length > 1) {
    const pct = this.flightData.progressPercent;
    let idx = 0;
    for (let i = 1; i < this.waypoints.length; i++) {
      if (this.waypoints[i].pct > pct) {
        idx = i - 1;
        break;
      }
    }
    // wp1, wp2 sont deux waypoints cons√©cutifs pour la fraction courante
    const wp1 = this.waypoints[idx];
    const wp2 = this.waypoints[Math.min(idx + 1, this.waypoints.length - 1)];
    const lat1 = wp1.lat, lon1 = wp1.lon;
    const lat2 = wp2.lat, lon2 = wp2.lon;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
    const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180)
            - Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
    let brng = Math.atan2(y, x) * 180 / Math.PI;
    if (brng < 0) brng += 360;
    return brng;
  }
  return 90; // cap par d√©faut (est)
}
```

* **Principe** :

  1. On cherche l‚Äôindice `idx` tel que `waypoints[idx].pct ‚â§ flightData.progressPercent < waypoints[idx + 1].pct`.
  2. On d√©finit `wp1 = this.waypoints[idx]` et `wp2 = this.waypoints[idx+1]` ou le dernier.
  3. On calcule le cap (`bearing`) du segment (wp1 ‚Üí wp2) sur la sph√®re, gr√¢ce √† la formule classique :

     $$
       \theta = \atan2\bigl(\sin(\Delta \lambda)\cos(\phi_2), 
                          \cos(\phi_1)\sin(\phi_2) - \sin(\phi_1)\cos(\phi_2)\cos(\Delta \lambda)\bigr).
     $$
  4. On ram√®ne l‚Äôangle en degr√©s normalis√©s (0‚Äì360).
* **‚úîÔ∏è** La formule est correcte pour obtenir le cap ‚Äútrue‚Äù (direction de vol) √† partir de deux paires (lat1,lon1) ‚Üí (lat2,lon2).
* Si on n‚Äôa pas assez de waypoints (moins de 2), on renvoie 90¬∞ par d√©faut. OK.

---

## 7. Bilan / Points de vigilance / Recommandations

### 7.1 Types lat/lon stock√©s sous forme de cha√Æne

* **Probl√®me** :

  * Apr√®s interpolation en grand-cercle, vous faites `lat_t_deg.toFixed(4)` ‚Üí c‚Äôest une cha√Æne (`string`). Pourtant, `WindowHublotComponent` attend que `@Input() lat: number` et `@Input() lon: number` soient des nombres.
* **Solution** :

  * Convertir imm√©diatement en nombre dans `updateDemoFlight` :

    ```ts
    const latNum = Number(lat_t_deg.toFixed(4));
    const lonNum = Number(lon_t_deg.toFixed(4));
    // ‚Ä¶
    const newFlightData = { 
      // ‚Ä¶
      lat_t_deg: latNum, 
      lon_t_deg: lonNum,
      // ‚Ä¶
    };
    ```
  * Ou bien, dans le template `<app-window-map-test [lat]="parseFloat(flightData.lat_t_deg)" ‚Ä¶>`, mais c‚Äôest moins propre.

### 7.2 Unit√© d‚Äôaltitude

* **Dans `WindowPage`**, vous manipulez `altitude` en **pieds** (ft).
* **Dans `WindowHublotComponent`**, vous aviez pr√©vu une formule qui convertit `altitude * 0.3048` pour passer en m√®tres avant de calculer le zoom et les limites de vue.
* V√©rifiez bien que **TOUTES** les fonctions de `WindowHublotComponent` re√ßoivent un `altitude` en ft, puis convertissent syst√©matiquement en m√®tre (`alt * 0.3048`) avant de faire les formules (zoom, viewRadius, etc.). Si un appel oublie cette conversion, le zoom sera fauss√© d‚Äôun facteur \~3,28.
* **Recommandation** :

  * Dans `WindowPage`, envoyez `[altitude]="(flightData?.altitude || 11000) * 0.3048"` pour transmettre un nombre en m√®tres, et modifiez `WindowHublotComponent` pour consid√©rer que l‚Äô`@Input() altitude` est d√©j√† en m.
  * Ou bien, laissez `[altitude]="flightData.altitude"` (en ft) et dans `WindowHublotComponent` commencez par :

    ```ts
    const altMeters = this.altitude * 0.3048;
    ```

    avant tout calcul.

### 7.3 Chargement / m√©moire

* Vous appelez `updateCurrentPOI()` **deux fois** par ticks (une fois dans `updateDemoFlight()`, une fois dans `setInterval`). C‚Äôest redondant. Mieux vaut garder `updateCurrentPOI()` soit √† l‚Äôint√©rieur de `updateDemoFlight()`, soit juste apr√®s dans le `setInterval`.

### 7.4 Affichage de la popup POI

* Vous testez `*ngIf="selectedPOI.image_url"`, mais vos objets `POI` n‚Äôont pas de champ `image_url` par d√©faut.
* Le code essaie ensuite d‚Äôafficher `<img [src]="selectedPOI.image_url" ‚Ä¶>`, mais comme c‚Äôest `undefined`, √ßa ne s‚Äôaffichera jamais.
* **Solution** : soit √©tendre `interface POI` en ajoutant un champ `image_url?: string`, soit enlever cette ligne `<img>` du template.

### 7.5 Coh√©rence des formules de zoom

* Dans votre ‚Äúliste d√©taill√©e‚Äù (section ‚ÄúPoints d'int√©r√™t du vol‚Äù), vous calculez le zoom via `getMapZoomFromAltitude(poi.altitude)`, avec une √©chelle lin√©aire `[0‚Ä¶40000] ft ‚Üí zoom [13‚Ä¶6]`.
* Dans `WindowHublotComponent`, vous aviez une formule plus sophistiqu√©e (bas√©e sur `log2(...)`) pour d√©terminer le zoom ‚Äúr√©el‚Äù qu‚Äôun passager verrait √† telle altitude.
* Ces deux approches ne sont pas identiques.

  * Si c‚Äôest juste pour afficher un chiffre dans la liste, ce n‚Äôest pas un probl√®me.
  * Mais soyez conscient que **le chiffre affich√© dans la liste** ne sera pas forc√©ment le m√™me que **le zoom effectif dans le hublot**.

### 7.6 Ajustements √©ventuels

* Vous avez fix√© la **distance lat√©rale de 10 km** pour les hublots (`const offsetKm = 10`). Selon votre pr√©f√©rence, vous pourriez rendre cette valeur param√©trable (via un `@Input()` de la page, par exemple).
* Le **cap** (issus de `getCurrentHeading()`) peut conna√Ætre une l√©g√®re instabilit√© si les waypoints sont proches (ex. fraction = 99 % et 100 %). Mais √ßa reste anecdotique.
* L‚Äôaffichage des donn√©es ‚ÄúflightTestData‚Äù est ind√©pendant du vol de d√©mo ; vous pouvez envisager de scinder ce bloc dans un autre component si vous voulez plus de clart√©.

---

## 8. Conclusion g√©n√©rale

1. **La structure de `WindowPage` est globalement juste** :

   * Vous initialisez un vol de d√©mo (Gen√®ve ‚Üí Ath√®nes) en calculant les dur√©es, la position, l‚Äôaltitude.
   * Vous g√©n√©rez des waypoints avec POIs et gardez un intervalle d‚Äôune seconde pour animer le progr√®s.
   * Vous affichez les donn√©es textuelles (heures, vitesse, distances, statut).
   * Vous g√©rez l‚Äôouverture/fermeture d‚Äôune popover pour chaque POI.
   * En bas, vous d√©ployez deux `WindowHublotComponent`, un pour la fen√™tre gauche et un pour la fen√™tre droite, avec un d√©calage lat√©ral de 10 km et la conversion d‚Äôaltitude.

2. **Points de vigilance √† corriger** :

   * Conversion **cha√Æne ‚Üí nombre** pour `lat_t_deg` / `lon_t_deg`.
   * Uniformisation de l‚Äô**unit√© d‚Äôaltitude** (ft vs m) entre `WindowPage` et `WindowHublotComponent`.
   * Suppression du test `selectedPOI.image_url` ou bien ajout d‚Äôun vrai champ `image_url` dans `ALL_POIS`.
   * √âliminer l‚Äôappel redondant √† `updateCurrentPOI()` (actuellement appel√© deux fois par tick).

3. **Une fois ces ajustements effectu√©s**, le code correspondra parfaitement √† l‚Äôobjectif :

   * la carte ‚Äúcockpit‚Äù/itin√©raire s‚Äôactualise avec la position (`WindowMapTestComponent`),
   * les deux hublots lat√©raux affichent chacun une mini-carte centr√©e sur la zone que verrait le passager (correctement zoom√©e selon l‚Äôaltitude, orient√©e √† gauche ou √† droite du cap),
   * les POIs sont mise en valeur dans la liste, et cliquables pour ouvrir la popup d‚Äôinfo.

N‚Äôh√©sitez pas √† me faire un retour sur la mani√®re dont vous voulez corriger l‚Äôaltitude ou les lat/lon en cha√Æne, et je pourrai vous fournir la version finale corrig√©e du composant si besoin.
